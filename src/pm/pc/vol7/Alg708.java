package pm.pc.vol7;

/**
 * Created by 高文文 on 2017/2/16.
 *
 * Problem ID: 110708	Repackaging
 *
 */
public class Alg708 {
    public static void main(String[] args) {
        Alg708 alg = new Alg708();

    }
}

/*
【题意】
给出几个包裹，每个包裹都包装好了3种大小的杯子。现在要重新包装，使向量
    a[1]*(s[1][1],s[1][2],s[1][3])+a[2]*(s[2][1],s[2][2],s[2][3])+.....+a[n]*(s[n][1],s[n][2],s[n][3])=(k,k,k).
就这样转化成了向量问题其中a[i]为非负整数，k为正整数。

【降维】
但是三维向量和这么多变量有点棘手，所以我们可以先降维，将原等式变化成：
    a[1]*(s[1][2]-s[1][1],s[1][3]-s[1][1])+ a[2]*(s[2][2]- s[2][1],s[2][3]- s[2][1])+.....+a[n]*(s[n][2]- s[n][1],s[n][3]- s[n][1])=(0,0).
把二维向量看成以平面坐标系中以原点为起点的向量：
    如果只有两个向量，因为a[i]为非负数，所以只有两个向量的时候夹角必须为PI
    n个向量的话，只要相邻两个向量的夹角不大于PI即可满足上述等式（PI=acos(-1); cosπ = -1）
【原理】
    转化为 2D 求点是否在凸包内的问题；
    问题：一个包装规格定义一个 2 维平面的向量（S2 - S1，S3 - S1），所求的就是这些向量组成的多边形是否包含原点（0，0）？
    解：如果包含原点，则有非负整数解，否则无非负整数解
    如果无解，向量都严格在经过原点的某条直线的半平面内。可以采用判断两个相邻向量之间的夹角，如果任意两个向量的夹角都不超过PI 弧度，则方程有解，否则无解。

【证明】
   向量a＝(x1,y1),向量b＝(x2,y2), a∥b的充要条件(或说成等价于)是x1y2-x2y1＝0；a⊥b的充要条件(或说成等价于)是x1x2+y1y2＝0；
   1. 当只有两个向量时
    ma + nc = 0 => n = - ma/c
    mb + nd = 0 => mb - mad/c = 0 => ad=cb => 当有两个向量的时候，这两个向量平行又因为这两个向量不同，则方向肯定是相反的，即两个向量夹角为π
   2. 当有N个向量时
考虑有 n 个向量 V1 - Vn，按向量与 X 轴成角的大
 小从小到大排列，如果相邻的某两个向量之间的夹角大于 PI 弧度，则可以从原点作一条直
 线，使得所有的向量都在这条直线的某一边，则当这 n 个向量都乘以某一个系数后，只会距
 离直线越来越远，故原点是不会在这些向量围成的多边形中的。若相邻向量的夹角都在 PI
 弧度以内，则可以将多余的向量去掉，留下三个向量，这三个向量之间的夹角都不超过 PI
 弧度，设为 W1，W2，W3，则一定有某个向量处于两外两个向量的中间，假设为 W2 处于
 W1 和 W3 中间，则可以找到适当的非负系数使得 x * W1 + y * W3 的和与 -W3 相等。
 系数是有理数，可以乘以相应的数使得 x 和 y 变成整数。根据以上分析，假设原点不再在
 众向量围成的多边形内，则所有向量必定在一个小于 PI 弧度的区域内。


【另分析，当不适用本题】
   x1 * a1 + x2 * a2 + ... + xn * an = k
   x1 * b1 + x2 * b2 + ... + xn * bn = k
   x1 * c1 + x2 * c2 + ... + xn * cn = k

   要求 xi >= 0，k > 0。可以设：

       [a1 a2 a3 ... an]
   A = [b1 b2 b3 ... bn]
       [c1 c2 c3 ... cn]

       [x1]
       [x2]
   X = [x3]
       [..]
       [xn]

       [k]
   C = [k]
       [k]

   有 A * X = C，要求矩阵乘积是否有非负数解。可以通过计算方程的系数矩阵和增广矩阵的
   秩来判断是否有解，但是只能是判断是否有非零解，不能判断是否有非负数解。这个办法好像
   行不通。

 */
