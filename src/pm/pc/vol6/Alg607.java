package pm.pc.vol6;

import java.math.BigInteger;

/**
 * Created by 高文文 on 2017/2/6.
 * Problem ID: 110607	Selfdescribing Sequence
 *
 * BigInteger大数+递推
 *
 */
public class Alg607 {

    public static void main(String[] args) {
        Alg607 alg = new Alg607();

    }



}

/*
// 显式的生成这个序列显然是超出内存限制也是没有必要的。有两种方法，一种是得出递推关系，一
// 种是根据序列特点得到某数的f（n）值。
//
// 递推方法：设 G（n） 表示满足 f（k） > f(k - 1) 时的自变量值，观察序列可以知道 G（1）
// = 2，G（2） = 4，G（3） = 6，G（4） = 9，... ，由序列的定义可以知道区间
// [G（n - 1），G（n）） 有 f（n） 个 n，则可以知道：
//
// G（n） = f（1） + f（2） + f（3） + ... + f（n） + 1
//
// 则有：
//
// G（n） = G（n - 1） + f（n）
//
// 由于已经知道 [G（n - 1），G（n）） 之间的数函数值都是 n。则可以通过以下方式计算
// G（n） 的值：
// G（1） = 2，G（2） = 4，k = 1，对于[G（k），G（k + 1））之间的数，其 f（n） =
// k + 1，则有 G（n） = G（n - 1） + k + 1。
//
// 非递推方法：根据以下事实，从 n = 3 开始对于序列中的每一对 f（n） = k，则必将在序列
// 中添加 f（n） * k 个元素。可以使用一个队列来记录添加的元素，计算将要添加的元素总数，
// 直到该队列将要产生的元素量超过指定数量。根据情况判定要求的 n 值的函数值。具体方法如下：
//
// 1. n = 1 或者 n = 2，特殊情况，予以特殊处理。
// 2. 设 sequence 为一个队列，记录该序列的元素，初始情况下，队列中存储了 n = 3 时的函
// 数值即 f（3） = 2。变量 total 根据 f（n） * k 的关系记录当前队列中存储元素所能产生
// 的元素总量，初始值为 0。变量 n 为当前的自变量值。
// 3. 从队列中取出第一个元素，设其值为 fn，可知 f（n） = fn。则队列所能产生元素个数
// total += fn * n。比较当前 n 与输入中要求函数值的数 k，若相等则表明 f（k） = fn。
// 否则继续计算 total 直到上限值。
// 4. 当前序列已经产生了足够的元素，最后能生成指定上限的元素，则继续从队列首位取出一个元
// 素，按前述步骤，只不过这时不需要实际在队列的最后添加元素，而是计算 total 的变化范围，
// 在 [total, total + fn) 之间数的函数值都是刚弹出的元素所对应的 n 值。同时仍应比对队
// 列首的 n 值，若有值对应，则该数的函数值就是弹出的队列元素值 fn。
// 5. 继续处理直到找到所有输入数的函数值，然后输出结果。


 */
